<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jonas Otto" />
  <title>GPU Programming</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="styling.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">GPU Programming</h1>
<p class="author">Jonas Otto</p>
<p class="date">August 2022</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#overview-graphics-pipeline"
id="toc-overview-graphics-pipeline">Overview: Graphics Pipeline</a></li>
<li><a href="#vertex-shader" id="toc-vertex-shader">Vertex Shader</a>
<ul>
<li><a href="#input-data-structures"
id="toc-input-data-structures">Input Data Structures</a></li>
<li><a href="#uniform-variables" id="toc-uniform-variables">Uniform
Variables</a></li>
<li><a href="#transformations"
id="toc-transformations">Transformations</a></li>
</ul></li>
<li><a href="#pixel-shader" id="toc-pixel-shader">Pixel Shader</a>
<ul>
<li><a href="#rasterization"
id="toc-rasterization">Rasterization</a></li>
<li><a href="#g-buffer" id="toc-g-buffer">G-Buffer</a></li>
<li><a href="#z-buffer" id="toc-z-buffer">Z-Buffer</a></li>
<li><a href="#lighting" id="toc-lighting">Lighting</a>
<ul>
<li><a href="#lambertian-reflectance-model"
id="toc-lambertian-reflectance-model">Lambertian Reflectance
Model</a></li>
<li><a href="#phong-reflectance-model"
id="toc-phong-reflectance-model">Phong Reflectance Model</a></li>
<li><a href="#blinn-phong-reflectance-model"
id="toc-blinn-phong-reflectance-model">Blinn-Phong Reflectance
Model</a></li>
</ul></li>
<li><a href="#texturing" id="toc-texturing">Texturing</a>
<ul>
<li><a href="#parallax-relief-mapping"
id="toc-parallax-relief-mapping">Parallax + Relief Mapping</a></li>
</ul></li>
<li><a href="#frame-buffers" id="toc-frame-buffers">Frame Buffers</a>
<ul>
<li><a href="#ambient-occlusion" id="toc-ambient-occlusion">Ambient
Occlusion</a></li>
</ul></li>
<li><a href="#sdfs" id="toc-sdfs">SDFs</a></li>
</ul></li>
<li><a href="#geometry-shader" id="toc-geometry-shader">Geometry
Shader</a>
<ul>
<li><a href="#inputs-and-outputs" id="toc-inputs-and-outputs">Inputs and
Outputs</a></li>
<li><a href="#geometry-generation-example-normal-visualization"
id="toc-geometry-generation-example-normal-visualization">Geometry
Generation Example: Normal visualization</a></li>
<li><a href="#shadow-volumes" id="toc-shadow-volumes">Shadow
volumes</a></li>
<li><a href="#layered-rendering" id="toc-layered-rendering">Layered
rendering</a></li>
</ul></li>
<li><a href="#tessellation-shader"
id="toc-tessellation-shader">Tessellation Shader</a>
<ul>
<li><a href="#subdivision-patterns"
id="toc-subdivision-patterns">Subdivision Patterns</a></li>
<li><a href="#tessellation-control-shader"
id="toc-tessellation-control-shader">Tessellation Control Shader</a>
<ul>
<li><a href="#tessellation-levels"
id="toc-tessellation-levels">Tessellation levels</a></li>
<li><a href="#inputs" id="toc-inputs">Inputs</a></li>
<li><a href="#outputs" id="toc-outputs">Outputs</a></li>
<li><a href="#synchronization"
id="toc-synchronization">Synchronization</a></li>
</ul></li>
<li><a href="#tessellation-evaluation-shader"
id="toc-tessellation-evaluation-shader">Tessellation Evaluation
Shader</a>
<ul>
<li><a href="#inputs-outputs" id="toc-inputs-outputs">Inputs +
Outputs</a></li>
<li><a href="#barycentric-coordinates"
id="toc-barycentric-coordinates">Barycentric Coordinates</a></li>
</ul></li>
<li><a href="#advanced-application-bezier-curves"
id="toc-advanced-application-bezier-curves">Advanced Application: Bezier
Curves</a></li>
</ul></li>
<li><a href="#advanced-glsl" id="toc-advanced-glsl">Advanced GLSL</a>
<ul>
<li><a href="#transform-feedback" id="toc-transform-feedback">Transform
Feedback</a></li>
<li><a href="#uniform-buffer-objects"
id="toc-uniform-buffer-objects">Uniform Buffer Objects</a></li>
<li><a href="#shader-storage-buffer-objects"
id="toc-shader-storage-buffer-objects">Shader Storage Buffer
Objects</a></li>
</ul></li>
<li><a href="#gpu-architecture" id="toc-gpu-architecture">GPU
Architecture</a>
<ul>
<li><a href="#processor-architecture"
id="toc-processor-architecture">Processor Architecture</a></li>
<li><a href="#thread-execution" id="toc-thread-execution">Thread
Execution</a></li>
<li><a href="#thread-divergence" id="toc-thread-divergence">Thread
Divergence</a>
<ul>
<li><a href="#predicated-instructions"
id="toc-predicated-instructions">Predicated instructions</a></li>
<li><a href="#voting" id="toc-voting">Voting</a></li>
</ul></li>
<li><a href="#memory" id="toc-memory">Memory</a>
<ul>
<li><a href="#shared-memory" id="toc-shared-memory">Shared
Memory</a></li>
</ul></li>
</ul></li>
<li><a href="#compute-shader" id="toc-compute-shader">Compute
Shader</a></li>
<li><a href="#cuda" id="toc-cuda">Cuda</a>
<ul>
<li><a href="#synchronization-1"
id="toc-synchronization-1">Synchronization</a></li>
<li><a href="#concurrency-streams"
id="toc-concurrency-streams">Concurrency: Streams</a></li>
</ul></li>
</ul>
</nav>
<h1 id="overview-graphics-pipeline">Overview: Graphics Pipeline</h1>
<p>The graphics pipeline running on the GPU consists of multiple
consecutive stages, some of which are programmable. The focus in this
lecture is on those programmable Stages, and how to program these using
GLSL shaders.</p>
<p>The basic pipeline consists of</p>
<ul>
<li>Vertex Shader</li>
<li>Tessellation
<ul>
<li>Control</li>
<li>Evaluation</li>
</ul></li>
<li>Geometry Shader</li>
<li>Fragment Shader</li>
</ul>
<p>Additionally, compute shaders can perform arbitrary computation and
can be used in various stages of the pipeline, or without using the
graphics pipeline at all.</p>
<h1 id="vertex-shader">Vertex Shader</h1>
<p>The vertex shader is executed once for every vertex in the scene. It
can transform the position and attributes of these vertices, and can
perform per-vertex calculations such as lighting (which can also be done
per-pixel, as explained later). A possible use case for moving vertices
is also animating objects in the scene.</p>
<h2 id="input-data-structures">Input Data Structures</h2>
<p>Input vertex data is in the form of primitives, which can be points,
lines, triangles and quads. Multiple triangles can be represented in
different ways:</p>
<ul>
<li><p>Triangle List: Each triangle consists of three points. Adjacent
triangles mean some points are stored twice.</p></li>
<li><p>Triangle Strip: The stored points make up a triangle strip in a
zig-zag pattern, from the bottom left towards the right. This way each
additional triangle only requires one additional point, the last two
points implicitly belong to the triangle.</p></li>
<li><p>Indexed Triangles: This performs deduplication of vertices by
storing each point once and defining triangles by the indices of the
points.</p>
<p>Input data is stored and uploaded in buffers, which can then be
associated to (vertex-)shader inputs.</p></li>
</ul>
<h2 id="uniform-variables">Uniform Variables</h2>
<p>Uniform variables have the same value for each invocation of the
shader (for every vertex/pixel). They are set by the CPU.</p>
<h2 id="transformations">Transformations</h2>
<p>Coordinate transformations are an important task of the vertex
shader. We express transformations using homogenous coordinates to allow
translations.</p>
<p><span class="math display">\[
\begin{bmatrix}
p_x * s_x + t_x \\
p_y * s_y + t_y \\
p_z * s_z + t_z \\
1
\end{bmatrix}
=
\begin{bmatrix}
s_x &amp; 0   &amp; 0   &amp; t_x \\
0   &amp; s_y &amp; 0   &amp; t_y \\
0   &amp; 0   &amp; s_z &amp; t_z \\
0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\begin{bmatrix}
p_x \\
p_y \\
p_z \\
1
\end{bmatrix}
\]</span> (add rotations to taste.)</p>
<p>Care has to be taken with normals, as those can change if geometry is
non-uniformly scaled. For a point <span class="math inline">\(p\)</span>
and normal <span class="math inline">\(n\)</span> under the
transformation <span class="math inline">\(M\)</span>: <span
class="math display">\[
p&#39; = Mp \\
\]</span> <span class="math display">\[
n&#39;=(M^{-1})^Tn
\]</span></p>
<blockquote>
<p><strong><em>TODO:</em></strong> Change of coordinate system
matrix</p>
</blockquote>
<h1 id="pixel-shader">Pixel Shader</h1>
<p>The pixel shader (fragment shader) runs after rasterization, for
every pixel. Its output is the desired color of the pixel, the inputs
are the outputs of the previous stages.</p>
<h2 id="rasterization">Rasterization</h2>
<h2 id="g-buffer">G-Buffer</h2>
<h2 id="z-buffer">Z-Buffer</h2>
<h2 id="lighting">Lighting</h2>
<h3 id="lambertian-reflectance-model">Lambertian Reflectance Model</h3>
<h3 id="phong-reflectance-model">Phong Reflectance Model</h3>
<h3 id="blinn-phong-reflectance-model">Blinn-Phong Reflectance
Model</h3>
<h2 id="texturing">Texturing</h2>
<h3 id="parallax-relief-mapping">Parallax + Relief Mapping</h3>
<h2 id="frame-buffers">Frame Buffers</h2>
<h3 id="ambient-occlusion">Ambient Occlusion</h3>
<h2 id="sdfs">SDFs</h2>
<h1 id="geometry-shader">Geometry Shader</h1>
<p>The geometry shader is located between the vertex- and pixel shader
in our pipeline. It is executed once for every geometric primitive.</p>
<h2 id="inputs-and-outputs">Inputs and Outputs</h2>
<p>Primitives for use in the geometry shader are</p>
<ul>
<li>Points</li>
<li>Lines</li>
<li>Triangles</li>
</ul>
<p>As well as lines and triangles with adjacency information. The input
is defined in the shader as</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">layout</span> <span class="op">(</span><span class="dt">triangles</span><span class="op">)</span> <span class="dt">in</span><span class="op">;</span></span></code></pre></div>
<p>The output of the geometry stage can be</p>
<ul>
<li>Points</li>
<li>Line strips</li>
<li>Triangle strips</li>
</ul>
<p>And is defined in the shader as</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">layout</span> <span class="op">(</span><span class="dt">triangle_strip</span><span class="op">,</span> <span class="dt">max_vertices</span> <span class="op">=</span> <span class="dv">3</span><span class="op">)</span> <span class="dt">out</span><span class="op">;</span></span></code></pre></div>
<p>The <code>max_vertices</code> parameter is required to specify the
maximum number of vertices that the shader may output.</p>
<p>The geometry shader receives inputs just as any other shader, but
since it processes a primitive instead of a single vertex, the inputs
will be arrays containing each input for each of the vertices making up
the primitive.</p>
<p>The usual <code>gl_Position</code> output from the vertex shader is
available at <code>gl_in[i].gl_Position</code>. Additional inputs are
available to receive an ID of the current primitive and shader
invocation.</p>
<p>Outputs do not become arrays, we instead call
<code>EmitVertex()</code> to emit the output variables for each vertex
one after another. Once all vertices have been output, we call
<code>EndPrimitive()</code>.</p>
<h2 id="geometry-generation-example-normal-visualization">Geometry
Generation Example: Normal visualization</h2>
<p>The geometry shader can also generate new geometry. This is explained
here with an example in which a steep pyramid shall be generated in the
middle of each triangle, visualizing its normal.</p>
<p>This requires generating four output triangles from one input
triangle primitive (the original triangle as well as all three sides of
the pyramid). To accomplish this, the <code>max_vertices</code>
parameter is increased to 12. The triangles are output individually (not
as a triangle strip), and <code>EndPrimitive()</code> is thus called
four times in the shader.</p>
<p>Another example given is the billboard example for molecule
visualization, with the difference being that the vertices for the
displaced billboard corners are not generated on the CPU, but created in
the geometry shader.</p>
<p>An example for the adjancency feature of the input is given by the
application of creating borders around a model: The input data now
consists of six vertices per triangle, containing not only the current
triangle but also the remaining vertices of the three triangles that
share an edge with the current triangle.</p>
<h2 id="shadow-volumes">Shadow volumes</h2>
<p>A way of generating shadows is to produce geometry representing the
projection of our objects based on the light position (the shaded
volume). When rendering, we can check if a point is inside a shadow
volume or not.</p>
<p>Using triangle adjacency, the contour edges of an object with respect
to the light (instead of the camera, like in the “borders” example) can
be found. These edges are then used to create a side of the shadow
volume.</p>
<p>The process of rendering shadows using shadow volumes is as
follows:</p>
<ol type="1">
<li>Render the scene using only ambient lighting, filling the
Z-buffer</li>
<li>Render the shadow volumes using the geometry shader, storing the
results in a “mask buffer”. This way the geometry does not need to be
explicitly stored. This is basically counting the number of front- and
back-facing sides of the shadow volumes between the camera and object.
If there are the same number of front- and back-facing sides, the object
is not in shadow.</li>
<li>Render the scene again, updating only pixels which are not marked in
the mask using diffuse and specular lighting</li>
</ol>
<p>Shadow volumes produce higher resolution (sharper) shadows than
shadow-mapping, at the cost of more expensive computation.</p>
<h2 id="layered-rendering">Layered rendering</h2>
<p>Another feature of the geometry shader is rendering the same object
to multiple images in one draw-call.</p>
<p>The geometry shader can calculate the projection of each object into
multiple camera configurations. The pixel shader is then executed for
each of those images. An example where this is needed is a CUBE map,
where the scene is rendered into the six faces of a cube.</p>
<p>In the geometry shader, before <code>EmitVertex()</code> we can
update <code>gl_Layer</code> to select which layer of the current
texture we want to render to. It is also not required to loop over
layers in the shader, instead <em>instancing</em> can be used to execute
the shader more than once for every primitive. The number of invocations
is specified in the shader:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">layout</span> <span class="op">(</span><span class="dt">invocations</span> <span class="op">=</span> <span class="dv">16</span><span class="op">,</span> <span class="dt">points</span><span class="op">)</span> <span class="dt">in</span><span class="op">;</span></span></code></pre></div>
<h1 id="tessellation-shader">Tessellation Shader</h1>
<p>Tessellation produces a more detailed model from a model with less
triangles. The tessellation shader allows us to subdivide triangles
based on the distance to the camera or other parameters.</p>
<p>In order to perform this tessellation, not one but two additional
stages are introduced between the vertex- and geometry shader: The
Tessellation Control Shader and the Tessellation Evaluation Shader.</p>
<p>The Tessellation Control Shader is executed once for each vertex of
the input primitives. Its goal is to determine the tessellation level,
or how much the triangle should be subdivided.</p>
<p>The Tessellation Evaluation Shader is executed once for each new
vertex that was created after subdivision. Its goal is to move the new
vertex to the correct position.</p>
<p>Actually generating the new primitives and vertices is done by the
GPU hardware, we can only configure that step using the control
shader.</p>
<h2 id="subdivision-patterns">Subdivision Patterns</h2>
<p>Multiple subdivision patterns are available:</p>
<ul>
<li>Triangles: Smaller triangle inside triangle</li>
<li>Quads: Smaller quads in quad</li>
<li>Quads Isolines: Parallel lines (with midpoints) along one axis
inside the quad</li>
</ul>
<h2 id="tessellation-control-shader">Tessellation Control Shader</h2>
<p>The goal of the TCS is to generate control points (inputs into
subdivision: three for triangles, four for quads) and to define the
tessellation levels.</p>
<p>This shader is executed once for each output control point, but all
executions for the same patch are connected: They share the same output
and can use synchronization.</p>
<h3 id="tessellation-levels">Tessellation levels</h3>
<p>For triangles, there is an <em>inner tessellation level</em> and
three <em>outer tessellation levels</em>. The inner tessellation level
is applied first and controls how many inner triangles are created (by
dividing all outer lines into <span class="math inline">\(n\)</span>
segments, with inner tessellation level <span
class="math inline">\(n\)</span>). Then, the outer tessellation levels
specify how many segments each of the original outer lines should
actually end up with.</p>
<p>The outer tessellation level is needed to correctly process adjacent
triangles, which may have different inner tessellation levels.</p>
<p>Usually, tessellation levels are dynamically calculated based on how
far the object is from the camera!</p>
<p>Tessellation of quads can be similarly controlled, although now there
are four outer tessellation levels and two inner tessellation levels
(one for each axis).</p>
<p>Isolines require just two outer tessellation levels.</p>
<h3 id="inputs">Inputs</h3>
<p>Some inputs are again provided in a <code>gl_in[]</code>, providing
for example the vertex positions. <code>gl_InvocationID</code> provides
the ID of the vertex inside the current primitive (indexing
<code>gl_in</code>), and <code>gl_PrimitiveID</code> identifies the
primitive. <code>gl_PatchVerticesIn</code> contains the number of
vertices in the current patch.</p>
<p>Custom shader inputs can be used as usual, in array form like in the
geometry shader.</p>
<h3 id="outputs">Outputs</h3>
<p><code>gl_out[i].gl_Position</code> contains the vertex position as
usual, the tessellation level as described above has to be written to
<code>gl_TessLevelOuter[4]</code> and
<code>gl_TessLevelInner[2]</code>.</p>
<p>Custom outputs for the TES are per control point by default, but can
be specified to be per primitive using</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">patch</span> <span class="dt">out</span> <span class="dt">vec3</span> customVar<span class="op">;</span></span></code></pre></div>
<h3 id="synchronization">Synchronization</h3>
<p>TCS instantiations can read outputs from other instantiations
belonging to the same patch. This requires synchronization, which is
provided by the <code>barrier()</code> function, ensuring that all
executions have written their outputs.</p>
<h2 id="tessellation-evaluation-shader">Tessellation Evaluation
Shader</h2>
<h3 id="inputs-outputs">Inputs + Outputs</h3>
<p>The TES is executed for each new vertex. It receives the barycentric
coordinates of each vertex in the original triangle as input, and
interpolates the new position for the vertex:
<code>gl_in[i].gl_Position</code> contains the positions of the patch
control points, <code>gl_TessCoord</code> contains the barycentric
coordinates of the current vertex.</p>
<p>The only required output is the position <code>gl_Position</code> of
the vertex.</p>
<h3 id="barycentric-coordinates">Barycentric Coordinates</h3>
<p>The order and spacing-mode of tesselation are specified:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">layout</span> <span class="op">(</span><span class="dt">triangles</span><span class="op">,</span> <span class="dt">equal_spacing</span><span class="op">,</span> <span class="dt">ccw</span><span class="op">)</span> <span class="dt">in</span><span class="op">;</span></span></code></pre></div>
<p>Multiple spacing modes such as <code>equal_spacing</code>,
<code>fractional_even_spacing</code> and
<code>fractional_even_spacing</code> are available. The barycentric
coordinates provides the vertex position as a weighted sum of the
control point positions.</p>
<p>For quads and isolines, the coordinates are given as <span
class="math inline">\(uv\)</span> coordinates inside the original
quad.</p>
<h2 id="advanced-application-bezier-curves">Advanced Application: Bezier
Curves</h2>
<p>An isolines tessellation with the first tessellation level being 1, a
bezier curve is rendered. The second tessellation level specifies the
number of segments in the curve.</p>
<p>The TES calculates the position of each vertex by evaluating the
bezier curve along the second axis of the quad (the one with varying
tessellation level).</p>
<p>This can be extended to bezier surfaces using quad tessellation.</p>
<h1 id="advanced-glsl">Advanced GLSL</h1>
<h2 id="transform-feedback">Transform Feedback</h2>
<h2 id="uniform-buffer-objects">Uniform Buffer Objects</h2>
<h2 id="shader-storage-buffer-objects">Shader Storage Buffer
Objects</h2>
<h1 id="gpu-architecture">GPU Architecture</h1>
<p>GPUs have progressed from the first fixed-function architectures, to
programmable shader stages and now unified shader execution units.
Today’s GPUs can execute many shader instantiations and programs in
parallel, independently of the shader stage. This is also what opened
the door to a wide variety of general purpose GPU computing (GPGPU).</p>
<h2 id="processor-architecture">Processor Architecture</h2>
<p>In order to leverage the data-parallel nature of the graphics
processing pipeline, large scale SIMT architectures are used. Processors
consist of multiple cores with a shared fetch/decode stage and execution
context. Multiple SIMT processors are combined into larger complexes,
which may be repeated multiple times. The GTX 1080 for example contains
20 “Streaming Multiprocessors”, each of which contains four
32-times-parallel SIMT processors, resulting in a total of 2560 cores in
the GPU.</p>
<h2 id="thread-execution">Thread Execution</h2>
<p>Threads are executed in <em>warps</em> of 32 threads each. This
matches the size of one SIMT processor.</p>
<h2 id="thread-divergence">Thread Divergence</h2>
<p>Since all threads on the same SIMT processor execute the same
instructions, special attention has to be paid to conditional
branching.</p>
<h3 id="predicated-instructions">Predicated instructions</h3>
<p>Using this method:</p>
<ul>
<li>All threads execute the predicate</li>
<li>All threads execute both branches</li>
</ul>
<p>The thread then selects one of the results based on the
predicate.</p>
<p>This is only viable if the branch is small, otherwise the performance
cost of executing both branches is too high.</p>
<h3 id="voting">Voting</h3>
<p>This approach allows the threads to vote which branch to execute. If
all threads vote for the same branch, the other branch is not
executed.</p>
<p>Thus, care has to be taken to avoid big branches that diverge within
the same warp.</p>
<h2 id="memory">Memory</h2>
<p>Accessing memory introduces latency, for example on the order of 100
cycles. The bandwidth between the processor and memory is also limited.
Stalling the processor while waiting for memory worsens utilization.</p>
<p>GPUs implement a memory hierarchy similar to CPUs:</p>
<p>The memory closest to the cores are registers, shared memory and L1
cache. For example, the GTX 1080 features</p>
<ul>
<li>256KB registers</li>
<li>96KB shared memory</li>
<li>48KB L1 cache</li>
</ul>
<p>The cache works without explicit user control and exploits spacial
and temporal locality of data accesses. A typical cache line size is 32
bytes, and transfer between memory and cache happens for entire cache
lines only. Efficient usage of the cache, and proper alignment of data
to cache lines are imperative for optimal performance, the performance
benefit usually originates in reduced memory bandwidth requirements,
which is often the bottleneck for processing speed.</p>
<p>The GPU hides memory latency by oversubscribing the SM with warps,
and executing other warps while some wait for memory. On the GTX 1080,
each SM can be assigned 64 active warps, while it’s only able to execute
four warps in parallel.</p>
<p>Switching between warps is fast, and is not comparable to a context
switch on the CPU. This does however mean that the number of warps per
SM (GPU occupancy) is also limited by the total register usage.</p>
<h3 id="shared-memory">Shared Memory</h3>
<p>Shared memory is fast memory close to the cores, with the restriction
that it is local to one streaming multiprocessor. The usual use case is
to explicitly move a hot region of memory to shared memory before
computation.</p>
<h1 id="compute-shader">Compute Shader</h1>
<blockquote>
<p><strong><em>TODO:</em></strong> Compute Shader</p>
</blockquote>
<h1 id="cuda">Cuda</h1>
<blockquote>
<p><strong><em>TODO:</em></strong> CUDA</p>
</blockquote>
<h2 id="synchronization-1">Synchronization</h2>
<h2 id="concurrency-streams">Concurrency: Streams</h2>
</body>
</html>
